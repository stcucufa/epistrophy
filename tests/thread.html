<!DOCTYPE html>
<html>
    <head>
        <title>Thread</title>
        <meta charset="utf8">
        <link rel="stylesheet" href="test.css">
        <script type="module">

import { test } from "./test.js";
import { notification } from "../lib/events.js";
import { Thread } from "../lib/thread.js";
import { K, svg } from "../lib/util.js";
import { VM } from "../lib/vm.js";

test("Thread", t => {
    const thread = Thread();
    t.atLeast(thread.id, 0, "id");
    t.equal(thread.ops, [], "empty ops");
});

test("instant(f)", t => {
    const vm = VM();
    const thread = vm.spawnAt(17);
    thread.instant(K("ok"));
    vm.clock.seek(18);
    t.equal(vm.valueOf(thread), "ok", "instant value");
});

test("constant(value)", t => {
    const vm = VM();
    const thread = vm.spawnAt(17);
    thread.constant("ok");
    vm.clock.seek(18);
    t.equal(vm.valueOf(thread), "ok", "constant value");
});

test("effect(f)", t => {
    const vm = VM();
    const thread = vm.spawnAt(17);
    let effect;
    thread.effect((value, t) => { effect = `${value}@${t}`; });
    vm.clock.seek(18);
    t.equal(effect, "undefined@17", "effect parameters");
    t.undefined(vm.valueOf(thread), "no value");
});

test("await(f)", async t => {
    const vm = VM();
    const thread = vm.spawnAt(17);
    thread.await(() => fetch("../icons.svg"));
    vm.clock.seek(18);
    t.undefined(vm.valueOf(thread), "no value yet");
    const { value } = await notification(vm, "await");
    vm.clock.seek(19);
    t.equal(vm.valueOf(thread), value, "value");
});

test("delay(dur)", t => {
    const vm = VM();
    const thread = vm.spawnAt(17);
    thread.delay(23);
    vm.clock.seek(31);
    t.equal(vm.scheduler.hasFuture, true, "delay...");
    vm.clock.seek(41);
    t.equal(vm.scheduler.hasFuture, false, "ended");
});

test("delay()", t => {
    const vm = VM();
    const thread = vm.spawnAt(17);
    thread.instant(K(23));
    thread.delay();
    vm.clock.seek(31);
    t.equal(vm.scheduler.hasFuture, true, "delay...");
    vm.clock.seek(41);
    t.equal(vm.scheduler.hasFuture, false, "ended");
    t.equal(vm.valueOf(thread), 23, "thread value");
});

test("set/unset(object, property)", t => {
    const vm = VM();
    const thread = vm.spawnAt(17);
    const object = { foo: "bar" };
    thread.instant(K("fum"));
    thread.set(object, "foo");
    thread.delay(23);
    thread.unset(object, "foo");
    vm.clock.seek(18);
    t.equal(object.foo, "fum", "property was set");
    vm.clock.seek(41);
    t.equal(object.foo, "bar", "property was unset");
    t.equal(vm.valueOf(thread), "fum", "thread value (set is an effect)");
});

test("setAttribute/unsetAttribute(element, attribute)", t => {
    const vm = VM();
    const thread = vm.spawnAt(17);
    const element = svg("path", { d: "M0,0" });
    thread.instant(K("M100,50"));
    thread.setAttribute(element, "d");
    thread.delay(23);
    thread.unsetAttribute(element, "d");
    vm.clock.seek(18);
    t.equal(element.getAttribute("d"), "M100,50", "attribute was set");
    vm.clock.seek(41);
    t.equal(element.getAttribute("d"), "M0,0", "attribute was unset");
    t.equal(vm.valueOf(thread), "M100,50", "thread value (set is an effect)");
});

test("event(target, type)", t => {
    const vm = VM();
    const thread = vm.spawnAt(17);
    thread.event(window, "synth");
    vm.clock.seek(31);
    const event = new window.Event("synth");
    window.dispatchEvent(event);
    t.undefined(vm.valueOf(thread), "no value before the event");
    vm.clock.seek(32);
    t.equal(vm.valueOf(thread), event, "event value");
});

test("label(name) and jump(name)", t => {
    const vm = VM();
    const thread = vm.spawnAt(17).
        instant(K(0)).
        label("loop").
        delay(23).
        instant(x => x + 1).
        jump("loop");
    vm.clock.seek(64);
    t.equal(vm.valueOf(thread), 2, "value after 2 iterations");
    vm.clock.seek(87);
    t.equal(vm.valueOf(thread), 3, "value after 3 iterations");
});

        </script>
    </head>
    <body>
        <p><a href="index.html">Back</a></p>
    </body>
</html>
