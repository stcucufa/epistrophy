<!DOCTYPE html>
<html>
    <head>
        <title>VM</title>
        <meta charset="utf8">
        <link rel="stylesheet" href="test.css">
        <script type="module">

import { test } from "./test.js";
import { notification } from "../lib/events.js";
import { K, nop } from "../lib/util.js";
import { VM } from "../lib/vm.js";
import { Thread } from "../lib/thread.js";

test("VM()", t => {
    const vm = VM();
    t.equal(vm.clock.now, 0, "clock starts at 0");
});

test("Start the clock", async t => {
    const vm = VM().start();
    await notification(vm.clock, "update");
    t.above(vm.clock.now, 0, `clock started (${vm.clock.now})`);
});

test("spawn(t = now)", t => {
    const vm = VM();
    const thread = vm.spawn();
    thread.instant(K("ok"));
    vm.clock.seek(1);
    t.equal(vm.valueOf(thread), "ok", "thread value");
});

test("spawnAt(t)", t => {
    const vm = VM();
    const thread = vm.spawnAt(17);
    thread.instant(K("ok"));
    vm.clock.seek(18);
    t.equal(vm.valueOf(thread), "ok", "thread value");
});

test("Run forward", t => {
    const vm = VM();
    const thread = vm.spawnAt(17);
    const succ = x => `succ(${x})`;
    thread.instant(K("zero"));
    thread.delay(23);
    thread.instant(succ);
    thread.delay(31);
    thread.instant(succ);
    vm.clock.seek(17);
    t.undefined(vm.valueOf(thread), "no value before t0");
    vm.clock.seek(18);
    t.equal(vm.valueOf(thread), "zero", "value in [t0, t1[");
    vm.clock.seek(41);
    t.equal(vm.valueOf(thread), "succ(zero)", "value in [t1, t2[");
    vm.clock.seek(72);
    t.equal(vm.valueOf(thread), "succ(succ(zero))", "value after t2");
});

test("Run backward", t => {
    const vm = VM();
    const thread = vm.spawnAt(17);
    const succ = x => `succ(${x})`;
    thread.instant(K("zero"));
    thread.delay(23);
    thread.instant(succ);
    thread.delay(31);
    thread.instant(succ);
    vm.clock.seek(72);
    t.equal(vm.valueOf(thread), "succ(succ(zero))", "value after t2");
    vm.clock.seek(71);
    t.equal(vm.valueOf(thread), "succ(zero)", "value in [t1, t2[");
    vm.clock.seek(40);
    t.equal(vm.valueOf(thread), "zero", "value in [t0, t1[");
    vm.clock.seek(17);
    t.undefined(vm.valueOf(thread), "no value before t0");
});

test("Do, undo, redo (value)", t => {
    const vm = VM();
    const thread = vm.spawnAt(17);
    const succ = x => `succ(${x})`;
    thread.instant(K("zero"));
    thread.delay(23);
    thread.instant(succ);
    vm.clock.seek(41);
    t.equal(vm.valueOf(thread), "succ(zero)", "do (twice)");
    vm.clock.seek(18);
    t.equal(vm.valueOf(thread), "zero", "undo");
    vm.clock.seek(41);
    t.equal(vm.valueOf(thread), "succ(zero)", "redo");
});

test("Do, undo, redo (effect)", t => {
    const vm = VM();
    const thread = vm.spawnAt(17);
    const effects = [];
    thread.effect(
        (_, t) => { effects.push(`${t}: Do #1`); },
        (_, t) => { effects.push(`${t}: Undo #1`); },
        (_, t) => { effects.push(`${t}: Redo #1`); }
    );
    thread.delay(23);
    thread.effect(
        (_, t) => { effects.push(`${t}: Do #2`); },
        (_, t) => { effects.push(`${t}: Undo #2`); },
        (_, t) => { effects.push(`${t}: Redo #2`); }
    );

    vm.clock.seek(41);
    t.equal(effects, ["17: Do #1", "40: Do #2"], "effects (do)");
    vm.clock.seek(18);
    t.equal(effects, ["17: Do #1", "40: Do #2", "40: Undo #2"], "effects (undo)");
    vm.clock.seek(41);
    t.equal(effects, ["17: Do #1", "40: Do #2", "40: Undo #2", "40: Redo #2"], "effects (redo)");
    vm.clock.seek(0);
    t.equal(
        effects,
        ["17: Do #1", "40: Do #2", "40: Undo #2", "40: Redo #2", "40: Undo #2", "17: Undo #1"],
        "effects (back to 0)"
    );
});

test("Do, undo, redo (event)", t => {
    const vm = VM();
    const thread = vm.spawnAt(17);
    const effects = [];
    thread.delay(23);
    thread.event(window, "A");
    thread.effect((_, t) => { effects.push(t); });
    thread.event(window, "B");
    thread.effect((_, t) => { effects.push(t); });

    vm.clock.seek(51);
    window.dispatchEvent(new window.Event("A"));
    vm.clock.seek(61);
    t.equal(effects, [51], "Event A");
    vm.clock.seek(47);
    window.dispatchEvent(new window.Event("A"));
    vm.clock.seek(71);
    window.dispatchEvent(new window.Event("B"));
    vm.clock.seek(72)
    t.equal(effects, [51, 71], "Event B");
});

test("Do, undo, redo (await)", async t => {
    const vm = VM();
    const thread = vm.spawnAt(17);
    thread.await(() => fetch("./icons.svg"));
    vm.clock.seek(18);
    const { value } = await notification(vm, "await");
    vm.clock.seek(19);
    t.equal(vm.valueOf(thread), value, "do");
    vm.clock.seek(0);
    t.undefined(vm.valueOf(thread), "undo");
    vm.clock.seek(19);
    t.equal(vm.valueOf(thread), value, "redo");
});

test("Do, undo, redo (jump)", t => {
    const vm = VM();
    let count = 0;
    const object = {};
    const thread = vm.spawn().
        delay(17).
        spawn(Thread().
            label("loop").
            delay(23).
            instant(() => ++count).
            set(object, "value").
            jump("loop")
        );
    vm.clock.seek(87);
    t.equal(object.value, 3, "value after 3 iterations");
    vm.clock.seek(41);
    t.equal(object.value, 1, "back to second iteration");
    vm.clock.seek(0);
    t.undefined(object.value, "back to first iteration");
    vm.clock.seek(87);
    t.equal(object.value, 3, "redo");
});

test("Bail on error (do)", t => {
    const vm = VM();
    const thread = vm.spawnAt(17).
        constant(-23).
        delay().
        constant("ko");
    t.errors(() => { vm.clock.seek(41); }, "error message in the console");
    t.equal(vm.valueOf(thread) instanceof Error, true, "thread error");
});

test("Bail on error (undo)", t => {
    const vm = VM();
    const thread = vm.spawnAt(17).
        constant("before").
        delay(23).
        effect(nop, () => { throw "could not undo!"; }).
        delay(31).
        constant("after");
    vm.clock.seek(72);
    t.equal(vm.valueOf(thread), "after", "do");
    t.errors(() => { vm.clock.seek(0); }, "error message during undo");
    // FIXME 2D05 Review valueOf(thread) when going backward
    // t.equal(vm.valueOf(thread) instanceof Error, true, "thread error (undo)");
});

test("Bail on error (redo)", t => {
    const vm = VM();
    const thread = vm.spawnAt(17).
        constant("before").
        delay(23).
        effect(nop, nop, () => { throw "could not redo!"; }).
        delay(31).
        constant("after");
    vm.clock.seek(72);
    t.equal(vm.valueOf(thread), "after", "do");
    vm.clock.seek(0);
    t.errors(() => { vm.clock.seek(72); }, "error message during redo");
    // FIXME 2D05 Review valueOf(thread) when going backward
    // t.equal(vm.valueOf(thread) instanceof Error, true, "thread error (redo)");
});

        </script>
    </head>
    <body>
        <p><a href="index.html">Back</a></p>
    </body>
</html>
